## 平台
牛客网

## 语言
python2.7.3

## 作业内容

### 题目描述
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列{1,2,4,7,3,5,6,8} 
     和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。



### 题目理解
[二叉树及其三种遍历](https://blog.csdn.net/qq_40772692/article/details/79343914)

#### 什么是二叉树

在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作 “左子树” 和“右子树”，
左子树和右子树同时也是二叉树。二叉树的子树有左右之分，并且次序不能任意颠倒。

#### [什么是递归](https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.2.%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92/)

递归是一种解决问题的方法，将问题分解为更小的子问题，直到得到一个足够小的问题可以被很简单的解决。
通常递归涉及函数调用自身。递归允许我们编写优雅的解决方案，解决可能很难编程的问题。

**满二叉树** 高度为 h，由 2^h-1 个节点构成的二叉树称为满二叉树。

![image](../../picture/work/满二叉树.png)


**完全二叉树** 具有 n 个节点的完全二叉树的深度为 [log2n]+1，
其中 [log2n]+1 是向下取整。满二叉树的深度为 k=log2(n+1)

![image](../../picture/work/完全二叉树.png)

#### 二叉树的遍历形式

* 先序遍历：按照根节点 -> 左子树 -> 右子树

![image](../../picture/work/二叉树的先序遍历.png)


先序遍历：(1)访问根节点；(2)采用先序递归遍历左子树；(3)采用先序递归遍历右子树

#### **思维过程**：

(1)先访问根节点 A

(2)A 分为左右两个子树，因为是递归调用，所以左子树也遵循 “先根节点 - 再左 - 再右” 的顺序，所以访问 B 节点，

(3)然后访问 D 节点，

(4)访问 F 节点的时候有分支，同样遵循 “先根节点 - 再左 -- 再右” 的顺序,

(5) 访问 E 节点，此时左边的大的子树已经访问完毕，

(6) 然后遵循最后访问右子树的顺序，访问右边大的子树，右边大子树同样先访问根节点 C,

(7) 访问左子树 G,

(8) 因为 G 的左子树没有，所以接下俩访问 G 的右子树 H,

* 中序遍历：按照左子树 -> 根节点 -> 右子树的顺序访问

![image](../../picture/work/二叉树的中序遍历.png)


中序遍历：(1)采用中序遍历左子树；(2)访问根节点；(3)采用中序遍历右子树

* 后序遍历

![image](../../picture/work/二叉树的后序遍历.png)


后序遍历：(1)采用后序递归遍历左子树；(2)采用后序递归遍历右子树；(3)访问根节点；

### 解题思路
分析二叉树的前序遍历和中序遍历的结果
* 前序遍历{1,2,4,7,3,5,6,8} 
* 中序遍历{4,7,2,1,5,3,8,6}
![image](../../picture/work/二叉树.png)

首先构建二叉树：
判断输入序列的长度
   * len=0 返回空
   * len=1 只存在一个根节点
   * len>1  
   未完待续。。。。
  


### 程序
```
-*- coding:utf-8 -*-
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    # 返回构造的TreeNode根节点
    def reConstructBinaryTree(self, pre, tin):
        # write code here
To be honest
    I don't understand
```


### 补充知识点
